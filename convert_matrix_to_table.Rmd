---
title: "convert matrix to datafram"
author: "Paul Bradshaw"
date: "27 March 2017"
output: html_document
---

```{r setup, include=FALSE}
#Make sure that the CSV data is formatted as numbers, without commas
regions <- read.csv('regionsquarematrix2015.csv')
```

To convert to matrix use `as.matrix`. However, if the first column contains words, then it will make *all* data text, so you need to omit the first column:

```{r}
regionsmatrix <- as.matrix(regions[,-1])
```

This means you have no row names:

```{r}
rownames(regionsmatrix) 
```

You can get the names from the columns and put them in as row names:

```{r}
rownames(regionsmatrix)  <- colnames(regionsmatrix)
rownames(regionsmatrix) 
```

Now we have the rows and columns both using the region names, and the data is numerical. *And* it's all in a matrix.

But how do we convert this to a format which can be used for network graphs?

## Data formats for network graphs

Network graphs normally need two sets of data:

1. A list of the entities to be graphed
2. A table of the relationships between the entities

Google Fusion Tables's network charts functionality only needs the second. But Kumu and D3 network charts, for example, need both. 

The table of relationships is the key part: the list of entities can always be generated from that (a pivot table, for example, will do this).

Normally that table has at least two columns: 

1. Column 1: the entity that the relationship comes *from*
2. Column 2: the entity that the relationship goes *to*
3. An optional column 3 might specify the *strength* of the relationship (for example, the amount of money, or the numbers of people, going from entity 1 to entity 2)
4. There might also be a column with some sort of *classification* of the relationship (for example, directorship, or family relationship)

We have data showing what regions people come from and go to, but it's not in that format. 

How do we get it in that format? It's good to mock up an example first so you know what it needs to look like. Here is what we need:

144 rows (12 x 12 relationships = 144) of 3 columns (from, to, amount).

The first row will be the 12 regions, in sequence, 12 times (North East, North West, Yorkshire...).
The second row will be each region, 12 times, in sequence (North East, North East, North East...).
The third row will be the numbers

This last row can actually be generated by using `array` like so, which turns a table into a vector:

```{r}
regionnums <- array(regionsmatrix)
```

What about the other columns? One way to get it in that format is to use loops.

### A basic loop

A basic `for` loop looks like this: `for (item in list of items) { do something each time}`

Here, for example, are two lines:

1. Create an empty vector variable called `rs`
2. Run a `for` loop which goes through the range of numbers 1 to 12, and for each adds it to that previously empty vector variable

When the loop has run 12 times (once for each item in that range of numbers), the vector contains all 12 numbers.

```{r}
rs <- c()
for (r in c(1:12)) { rs <-c(rs, r) }
```

Of course we don't want a list of numbers. Instead we can use those numbers to serve as *indexes* to grab items from another vector, like so:

```{r}
#First, make sure the rs variable is empty again, or we'll add to what we created before
rs <- c()
for (r in c(1:12)) { rs <-c(rs, regionnames[r]) }
```

The key part here is `regionnames[r]`: this uses `[r]` as an index to specify the item position in `regionnames` to grab. The first time the loop runs, when `r` is `1`, this means `regionnames[1]` (the first item in the vector `regionnames`)

Now, we need to convert our list of 12 regions into a list of 144 cells: each 12 regions must appear 12 times. To do that we need to put another loop *inside* of the loop above, like so:

```{r}
#First, make sure the rs variable is empty
rscol1 <- c()
for (r in c(1:12)) 
  { for (r in c(1:12)) 
    { rscol1 <-c(rscol1, regionnames[r]) }
  }
```

This is harder to get your head around, so break it down:

* The first loop starts at `1`
* While it is `1`, it then begins the second loop, and goes from 1 to 12. This grabs all 12 names from the vector and adds them once.
* The first loop then moves on to `2`
* The second loop *again* grabs the 12 names from the vector, and appends them, so we now have the same 12 names twice, in sequence.
* This process repeats so we end up with the list of 12 names appended 12 times to that original empty list.

### The loop for the second column

Here's the loop to create the second column. What's changed? Well, apart from the name of the vector being created: `rscol2`

```{r}
rscol2 <- c()
for (r1 in c(1:12)) 
  { for (r2 in c(1:12)) 
    { rscol2 <-c(rscol2, regionnames[r1]) }
  }
```

The difference is that in the previous code `r` was used for the number being grabbed in both loops. This time we're differentiating: the first loop calls each item `r1` as it cycles through. The second loop: `r2`.

What this means is that while the second loop is running 12 times, the actual *number* (1, 2, 3, whatever) isn't *used* for anything. Instead `r1` is used as the *index*. So it runs 12 times using the index 1, then 12 times using the index 2, and so on. This generates a list that looks different. 

## Combining the results into a data frame

We now have three vectors containing our three columns. To combine them into a data frame we use... `data.frame`:

```{r}
networktable <- data.frame(rscol1, rscol2, regionnums)
#Rename the columns
column_names <- c('destination', 'origin', 'numbers')
colnames(networktable) <- column_names
write.csv(networktable, 'networktable.csv')
```

We can make this adapt to another similar matrix by using the length of the column as the end of our range.

## Saving the code as a reusable R script

If we expect to run this in other projects and not just this one, we can save it as an R script and then run it in different projects. 

To do this, select **File > New File > R Script**. Paste your code in there, and then save it (it will save in the same directory as the current R project).

To run the script use the `source` command followed by the name that you used for the script, in inverted commas. If you called the script 'squaretabletolong', for example, the code to run that script would be:

```{r}
source('squaretabletolong.R')
```

